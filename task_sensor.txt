Analisis y Descripcion de los codigos fuentes TP2_02:

task_sensor.c:
Este archivo define una tarea del sistema embebido encargada de leer sensores tipo pulsadores (botones A, B, C, D) y generar eventos al sistema principal.

 Arreglos de estructuras:
 
 1) Se define una lista de estructuras task_sensor_cfg_list[] tal que cada estructura será
 representativa de cada entrada (botón) que podramos tener a disposición en un futuro.
 Cada elemento de esos structs serán relativos a lo que hace cada una de esas entradas (Señales,
 eventos, pines, etc).
  Cada estructura incluye:
   Identificador del botón (ID_BTN_A, etc.).
   Puerto y pin del microcontrolador.
   Nivel lógico de pulsación (BTN_A_PRESSED).
   Tiempo de retardo máximo (DEL_BTN_XX_MAX).
   Eventos a generar (signal_up y signal_down).
 
 2) task_sensor_dta_list[] define el estado inicial de cada boton.
  Cada entrada representa el estado actual de un sensor: {DEL_BTN_XX_MIN, ST_BTN_XX_UP, EV_BTN_XX_UP}
   Contiene:
    tick → contador de tiempo para debouncing.
    state → estado actual (UP, DOWN, FALLING, RISING).
    event → evento detectado (EV_BTN_XX_UP / DOWN).

 Variables globales
   g_task_sensor_cnt -> Contador de ejecuciones de la tarea
   volatile uint32_t g_task_sensor_tick_cnt -> Señal de tiempo consumida por task_sensor_update
   task_sensor_dta_list[]	-> arreglo de task_sensor_dta_t	mantiene el estado y temporización de cada sensor
   task_sensor_cfg_list[]	-> arreglo de task_sensor_cfg_t	define la configuración hardware de cada sensor

 ---------------------------------------------------------------------------------------------------------------------------

task_sensor_attribute.h:
Define la tabla de estados del sensor tipo botón (Task Sensor).

Tipos de datos:
 task_sensor_ev_t -> Enumera los eventos que pueden excitar la FSM del sensor. Representa los eventos externos que cambian el estado del sensor.
 task_sensor_st_t -> Enumera los estados posibles de la FSM. Define la etapa actual del ciclo del botón, gestionando las transiciones con temporización (tick).
 task_sensor_id_t -> Identifica de manera única cada sensor o botón. Permite referirse a cada botón de forma simbólica, en lugar de por número de pin o puerto.
 task_sensor_cfg_t -> Estructura de configuración estática de cada botón o sensor.
 task_sensor_dta_t -> Estructura de datos dinámicos de cada botón. Guarda la información cambiante de cada sensor (estado, temporización y evento actual). Se actualiza en cada ciclo de ejecución de task_sensor(). Es un array de estructuras, donde cada elemento corresponde a un botón físico (A, B, C, D). Permite recorrer todos los sensores dentro de la tarea principal del módulo.

Patrón de diseño:
Cada sensor mantiene su propio estado (task_sensor_dta_t). La lógica de transición está documentada explícitamente en forma tabular. Las acciones (tick--, put_event_task_system) se ejecutan como efectos secundarios de cada transición. Permite instancias múltiples del mismo autómata (un por botón) sin duplicar código.

 ---------------------------------------------------------------------------------------------------------------------------

task_sensor.png
 Representa la máquina de estados finita (FSM) que modela el comportamiento dinámico del sensor de botón dentro del sistema embebido. 
 Cada botón (A, B, C, D) implementa una instancia de esta máquina de estados, la cual gestiona:
  La detección de presionado y liberado.
  El control de rebote mediante el contador tick.
  El envío de eventos al sistema (raise EV_SYS_XX_*) cuando se detectan acciones válidas.

Descripción general del modelo:
La máquina de estados tiene cuatro estados principales:
  ST_BTN_XX_UP → Botón en reposo (no presionado).
  ST_BTN_XX_FALLING → Transición de suelto a presionado (fase de rebote descendente).
  ST_BTN_XX_DOWN → Botón presionado estable.
  ST_BTN_XX_RISING → Transición de presionado a suelto (fase de rebote ascendente).
 El prefijo XX se reemplaza por el identificador del botón (A, B, C, D).
 El estado inicial (círculo negro) lleva directamente a ST_BTN_XX_UP, indicando que el sistema arranca con todos los botones en reposo.

Descripción de los eventos
 EV_BTN_XX_PRESSED	-> Señal lógica que indica una presión detectada en el pin del GPIO.	Inicia transición a FALLING o RISING según estado actual.
 EV_BTN_XX_HOVER	-> Señal periódica de muestreo o mantenimiento.	Permite controlar el rebote mediante tick--.
 EV_SYS_XX_ACTIVE	-> Evento del sistema indicando botón activado (presionado confirmado).	Notifica a otras tareas o capas del sistema.
 EV_SYS_XX_IDLE	-> Evento del sistema indicando botón inactivo (liberado confirmado).	Notifica a otras tareas o capas del sistema.

Estructuras:
task_sensor_cfg_t	-> Define el hardware (pin, puerto, polaridad, delays).
task_sensor_dta_t	-> Guarda el estado y tick de cada botón.
task_sensor_ev_t y task_sensor_st_t	-> Tipos enumerados que modelan los eventos y estados del diagrama.
______________________________________________________________________________________________

Evolucion de g_app_runtime_us

Al iniciar cada ciclo de actualización de la aplicación, g_app_runtime_us se reinicia. Luego, se ejecutan todas las tareas.
Para cada tarea se mide el tiempo de ejecución real en microsegundos usando el DWT cycle counter.
Ese tiempo se acumula en g_app_runtime_us.
Al terminar el ciclo, g_app_runtime_us contiene el tiempo total de CPU consumido por todas las tareas en esa iteración.
En el siguiente ciclo de app_update(), el proceso se repite: se reinicia y vuelve a calcularse.
Comienza en Value = 0 y termina en Value = 20. Al presionar el botón baja a Value = 19 y al soltarlo sube a 20. 

Evolucion WCET

El WCET de cada tarea se pone en cero.
Cada vez que se ejecuta una tarea, se mide cuánto tardó en ese ciclo utilizando cycle_counter_time_us.
Si ese tiempo supera al WCET guardado, se actualiza y si es menor o igual, el WCET no cambia.
Cada WCET (de task_tda_list[x]) comienza en 0.
- WCET del [0] cambia a 12
- WCET del [1] cambia a 4
- WCET del [2] cambia a 4
Luego, al presionar el botón cambian a 14, 6, 5, respectivamente.




